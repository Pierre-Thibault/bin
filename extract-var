#!/usr/bin/env bash
# Extract selected expression into a variable
# Usage in Helix: select expression, then | extract
#                 or | extract variable_name

# Read API key
GROQ_KEY_FILE="$HOME/secrets/groq"

if [ ! -f "$GROQ_KEY_FILE" ]; then
  echo "Error: API key file not found at $GROQ_KEY_FILE" >&2
  exit 1
fi

GROQ_API_KEY=$(cat "$GROQ_KEY_FILE" | tr -d '[:space:]')

# Get variable name from arguments (optional)
var_name="$*"
if [ -z "$var_name" ]; then
  var_instruction="choose an appropriate variable name"
else
  var_instruction="use the variable name: $var_name"
fi

# Read the expression from stdin
expression=$(cat)

# Create prompt
prompt="Extract this expression into a variable. Detect the programming language automatically. ${var_instruction}. Output the variable declaration followed by the variable name replacing the original expression. Preserve exact indentation. Output ONLY code, no explanations, no markdown fences.

Expression to extract:
$expression"

# Call Groq API
response=$(curl -s https://api.groq.com/openai/v1/chat/completions \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $GROQ_API_KEY" \
  -d "{
    \"model\": \"llama-3.3-70b-versatile\",
    \"messages\": [{
      \"role\": \"system\",
      \"content\": \"You are a code refactoring assistant. Extract expressions into variables with proper syntax for the detected language. Output only code, never explanations or markdown.\"
    }, {
      \"role\": \"user\",
      \"content\": $(echo "$prompt" | jq -Rs .)
    }],
    \"temperature\": 0.1,
    \"max_tokens\": 1024
  }")

# Extract response
result=$(echo "$response" | jq -r '.choices[0].message.content // "Error: No response"')

# Remove any markdown code fences that might slip through
echo "$result" | sed -e '/^```/d' -e 's/^```.*$//'
